// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

// Include your device-specific headers, and edit functions below
// #include "hal.h"

#include "mongoose_glue.h"
#include "cmsis_os.h"

struct INTERNET_CONFIG tcpConfig = { .ip   = MG_U32(10,14,64,15) ,//MG_U32(10,14,16,34) ,
									 .mask = MG_U32(255,255,254,0),
									 .gw   = MG_U32(10,14,64,1),
									 .mqttBroker = "mqtt://10.14.64.11:1991",
									 .mqttUser =   "thaco" ,
									 .mqttPass =   "thaco1234",
									 .s_sub_handle = "shuttle/handle",
									 .s_sub_run = "shuttle/run",
									 .s_sub_admin = "shuttle/admin",
									 .s_pub_info = "shuttle/information",
									 .s_pub_report = "shuttle/report" ,
									 .s_pub_complete = "shuttle/completeMission" ,
									 .no = "001"  };
uint8_t *tcpConnectState;
osMutexId_t mqttMutex;

char topicBff[3][64];
void createTopicPub()
{
	mg_snprintf(topicBff[0], sizeof(topicBff[0]), "%s/%s", tcpConfig.s_pub_info, tcpConfig.no);
	mg_snprintf(topicBff[1], sizeof(topicBff[0]), "%s/%s", tcpConfig.s_pub_report, tcpConfig.no);
	mg_snprintf(topicBff[2], sizeof(topicBff[0]), "%s/%s", tcpConfig.s_pub_complete, tcpConfig.no);
}
void user_tcpip_cf()
{
	static struct mg_tcpip_driver_stm32h_data driver_data_;
	    static struct mg_tcpip_if mif_;
	    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;
	    driver_data_.phy_addr = MG_TCPIP_PHY_ADDR;
	    driver_data_.phy_conf = MG_TCPIP_PHY_CONF;
	    mif_.ip = mg_htonl(tcpConfig.ip);
	    mif_.mask = mg_htonl(tcpConfig.mask);
	    mif_.gw = mg_htonl(tcpConfig.gw);
	    mif_.driver = &mg_tcpip_driver_stm32h;
	    mif_.driver_data = &driver_data_;
	    MG_SET_MAC_ADDRESS(mif_.mac);
	    mg_tcpip_init(&g_mgr, &mif_);
	    MG_INFO(("Driver: stm32h, MAC: %M", mg_print_mac, mif_.mac));
	    tcpConnectState = &mif_.state;
}

void glue_init(void) {
  MG_DEBUG(("Custom init done"));
  mg_log_set(MG_LL_ERROR) ;
  createTopicPub();
  mg_timer_add(&g_mgr, 200, MG_TIMER_REPEAT, ws_transmit_timer, &g_mgr);  // hÃ m timer websocket
}

void glue_lock_init(void) {  // callback to initialize the MQTT semaphore
	mqttMutex = osMutexNew(NULL);
}

void glue_lock(void) {  // Lock mutex. Implement only if you use MQTT publish
	osMutexAcquire(mqttMutex, osWaitForever);
}

void glue_unlock(void) {  // Unlock mutex. Implement only if you use MQTT publish
	osMutexRelease(mqttMutex);
}

void glue_mqtt_tls_init(struct mg_connection *c) {
  bool is_tls = mg_url_is_ssl(tcpConfig.mqttBroker);
  MG_DEBUG(("%lu TLS enabled: %s", c->id, is_tls ? "yes" : "no"));
  if (is_tls) {
    struct mg_tls_opts opts;
    memset(&opts, 0, sizeof(opts));
    // opts.ca = mg_str(ca_certificate);
    mg_tls_init(c, &opts);
  }
}

// Called when we connected to the MQTT server
void glue_mqtt_on_connect(struct mg_connection *c, int code) {
  char* path = mg_mprintf("%s/%s", tcpConfig.s_sub_handle, tcpConfig.no);
  struct mg_mqtt_opts opts;
  memset(&opts, 0, sizeof(opts));
  opts.qos = 1;
  opts.topic = mg_str(path);
  mg_mqtt_sub(c, &opts);
  MG_DEBUG(("%lu code %d. Subscribing to [%.*s]", c->id, code, opts.topic.len,
            opts.topic.buf));
  path = mg_mprintf("%s/%s", tcpConfig.s_sub_run, tcpConfig.no);
  memset(&opts, 0, sizeof(opts));
  opts.qos = 1;
  opts.topic = mg_str(path);
  mg_mqtt_sub(c, &opts);
  MG_DEBUG(("%lu code %d. Subscribing to [%.*s]", c->id, code, opts.topic.len,
            opts.topic.buf));
  path = mg_mprintf("%s/%s", tcpConfig.s_sub_admin, tcpConfig.no);
  memset(&opts, 0, sizeof(opts));
  opts.qos = 1;
  opts.topic = mg_str(path);
  mg_mqtt_sub(c, &opts);
  MG_DEBUG(("%lu code %d. Subscribing to [%.*s]", c->id, code, opts.topic.len,
            opts.topic.buf));
  free(path);
}

// This function gets called for every received MQTT message
void glue_mqtt_on_message(struct mg_connection *c, struct mg_str topic,
                          struct mg_str data) {


}

void mqtt_publish(struct mg_str message, SelectTopic selectTopic)
{
	struct mg_mqtt_opts pub_opts;
	memset(&pub_opts, 0, sizeof(pub_opts));
	switch (selectTopic) {
		case SELECT_INFO_TOPIC:
			pub_opts.topic = mg_str(topicBff[0]);
			break;
		case SELECT_REPORT_TOPIC:
			pub_opts.topic = mg_str(topicBff[1]);
			break;
		case SELECT_COMPLETE_TOPIC:
			pub_opts.topic = mg_str(topicBff[2]);
			break;
		default:
			break;
	}
	pub_opts.qos = 1;
	pub_opts.message = message;
	if (g_mqtt_conn != NULL)
	{
		glue_lock();
		mg_mqtt_pub(g_mqtt_conn, &pub_opts);
	    glue_unlock();
	}

}

void glue_mqtt_on_cmd(struct mg_connection *c, struct mg_mqtt_message *mm) {
  MG_DEBUG(("%lu cmd %d qos %d", c->id, mm->cmd, mm->qos));
}

struct mg_connection *glue_mqtt_connect(struct mg_mgr *mgr,
                                        mg_event_handler_t fn) {
  const char *url = tcpConfig.mqttBroker;
  struct mg_mqtt_opts opts;
  memset(&opts, 0, sizeof(opts));
  opts.clean = true;
  opts.user = mg_str(tcpConfig.mqttUser);
  opts.pass = mg_str(tcpConfig.mqttPass);
  opts.version = 4 ;
  return mg_mqtt_connect(mgr, url, &opts, fn, NULL);
}

void glue_websocket_on_message(struct mg_connection *c,struct mg_ws_message *wsm)
{
	websocketCallback(c, wsm);
}

// Authenticate user/password. Return access level for the authenticated user:
//   0 - authentication error
//   1,2,3... - authentication success. Higher levels are more privileged than lower
int glue_authenticate(const char *user, const char *pass) {
  int level = 0; // Authentication failure
  if (strcmp(user, "admin") == 0 && strcmp(pass, "admin") == 0) {
    level = 7;  // Administrator
  } else if (strcmp(user, "user") == 0 && strcmp(pass, "user") == 0) {
    level = 3;  // Ordinary dude
  }
  return level;
}


// reboot
static uint64_t s_action_timeout_reboot;  // Time when reboot ends
bool glue_check_reboot(void) {
  return s_action_timeout_reboot > mg_now(); // Return true if reboot is in progress
}
void glue_start_reboot(void) {
  s_action_timeout_reboot = mg_now() + 1000; // Start reboot, finish after 1 second
}

// firmware_update
void  *glue_ota_begin_firmware_update(char *file_name, size_t total_size) {
  bool ok = mg_ota_begin(total_size);
  MG_DEBUG(("%s size %lu, ok: %d", file_name, total_size, ok));
  return ok ? (void *) 1 : NULL;
}
bool  glue_ota_end_firmware_update(void *context) {
  bool ok = mg_ota_end();
  MG_DEBUG(("ctx: %p, success: %d", context, ok));
  if (ok) {
    MG_INFO(("Rebooting in %lu ms", WIZARD_REBOOT_TIMEOUT_MS));
    mg_timer_add(&g_mgr, WIZARD_REBOOT_TIMEOUT_MS, 0,
      (void(*)(void *)) mg_device_reset, NULL);
  }
  return ok;
}
bool  glue_ota_write_firmware_update(void *context, void *buf, size_t len) {
  MG_DEBUG(("ctx: %p %p/%lu", context, buf, len));
  return mg_ota_write(buf, len);
}

// file_upload
void  *glue_file_open_file_upload(char *file_name, size_t total_size) {
  char path[128], *p = NULL;
  FILE *fp = NULL;
  if ((p = strrchr(file_name, '/')) == NULL) p = file_name;
  mg_snprintf(path, sizeof(path), "/tmp/%s", p);
#if MG_ENABLE_POSIX_FS
  fp = fopen(path, "w+b");
#endif
  MG_DEBUG(("opening [%s] size %lu, fp %p", path, total_size, fp));
  return fp;
}
bool  glue_file_close_file_upload(void *fp) {
  MG_DEBUG(("closing %p", fp));
#if MG_ENABLE_POSIX_FS
  return fclose((FILE *) fp) == 0;
#else
  return false;
#endif
}
bool  glue_file_write_file_upload(void *fp, void *buf, size_t len) {
  MG_DEBUG(("writing fp %p %p %lu bytes", fp, buf, len));
#if MG_ENABLE_POSIX_FS
  return fwrite(buf, 1, len, (FILE *) fp) == len;
#else
  return false;
#endif
}

// graph1
size_t glue_graph_get_graph1(uint32_t from, uint32_t to,
                              uint32_t *x_values, double *y_values, size_t len) {
  size_t i = 0;
  uint32_t timestamps[] = {1724576787,1724576847,1724576907,1724576967,1724577027,1724577087,1724577147,1724577207,1724577267,1724577327};  // Those are example values
  double values[] = {20.3,27.2,29.7,27.9,25.1,23.8,22.5,22.2,23.3,23.9};  // Use real device data
  for (i = 0; i < len; i++) {
    if (i >= sizeof(values) / sizeof(values[0])) break;
    x_values[i] = timestamps[i];
    y_values[i] = values[i];
  }
  (void) from, (void) to;
  return i;
}

static struct state s_state = {42, 27, 70, 10, "1.0.0", true, false, 83};
void glue_get_state(struct state *data) {
  *data = s_state;  // Sync with your device
}
void glue_set_state(struct state *data) {
  s_state = *data; // Sync with your device
}

static struct leds s_leds = {false, true, false};
void glue_get_leds(struct leds *data) {
  *data = s_leds;  // Sync with your device
}
void glue_set_leds(struct leds *data) {
  s_leds = *data; // Sync with your device
}

static struct settings s_settings = {"edit & save me", 2, 123.12345, 17, true};
void glue_get_settings(struct settings *data) {
  *data = s_settings;  // Sync with your device
}
void glue_set_settings(struct settings *data) {
  s_settings = *data; // Sync with your device
}

static struct security s_security = {"admin", "user"};
void glue_get_security(struct security *data) {
  *data = s_security;  // Sync with your device
}
void glue_set_security(struct security *data) {
  s_security = *data; // Sync with your device
}

__attribute__((weak)) void websocketCallback(struct mg_connection *con, struct mg_ws_message *wsm ) {}
__attribute__((weak)) void mqttCallback(struct mg_connection *con, struct mg_mqtt_message *mqttm ) {}
__attribute__((weak)) void ws_transmit_timer(void *arg) {}
